# This workflow performs internal reconnaissance of the AWDL/AirDrop stack on macOS.
# It identifies the awdl0 interface and key daemons, then uses powerful system
# tracing tools to monitor and log their activity. The goal is to collect
# detailed data on system calls, file access, and network interactions, which
# can be analyzed to discover new vulnerability vectors.

name: Internal AWDL and AirDrop System Trace
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering for targeted runs

jobs:
  discover-and-trace-awdl:
    runs-on: macos-latest

    steps:
      # Step 1: Discover network interfaces and key processes
      # We start by listing all network interfaces to find awdl0 and getting the
      # Process ID (PID) of sharingd, the primary daemon for AirDrop.
      - name: Discover Interfaces and Daemons
        id: discovery
        run: |
          echo "--- Discovering Network Interfaces ---"
          ifconfig -a > ifconfig_output.txt
          if grep -q "awdl0" ifconfig_output.txt; then
            echo "✅ awdl0 interface found."
          else
            echo "⚠️ awdl0 interface not found. It may be inactive."
          fi

          echo "\n--- Finding Key Daemons ---"
          SHARINGD_PID=$(pgrep -x sharingd || echo "not_found")
          if [ "$SHARINGD_PID" != "not_found" ]; then
            echo "✅ sharingd daemon found with PID: $SHARINGD_PID"
            echo "SHARINGD_PID=$SHARINGD_PID" >> $GITHUB_ENV
          else
            echo "❌ sharingd daemon not running."
            # We continue anyway to capture system-wide wireless events.
          fi

      # Step 2: Use dtrace to create a system call listener
      # This DTrace script (dlistener.d) will attach to key functions within the
      # kernel related to AWDL and log any activity.
      - name: Create AWDL DTrace Listener
        run: |
          echo "Creating DTrace script to monitor kernel-level AWDL activity..."
          cat > dlistener.d << 'EOF'
          #!/usr/sbin/dtrace -s

          # This script traces AWDL functions in the kernel.
          # NOTE: This requires System Integrity Protection (SIP) to be at least partially disabled.
          # It may not run fully in a default GitHub Actions environment but is provided
          # for use on a dedicated research machine.

          fbt:kernel:awdl_net_add_if:entry,
          fbt:kernel:awdl_net_del_if:entry,
          fbt:kernel:awdl_control_path_send_tlv:entry,
          fbt:kernel:awdl_control_path_receive_frame:entry
          {
            printf("PID %d (%s) triggered %s::%s\n", pid, execname, probemod, probefunc);
          }
          EOF
          echo "✅ DTrace script created."

      # Step 3: Run Tracers to Capture System Activity
      # We will run multiple tracers simultaneously for a short duration.
      # - dtrace: Captures deep kernel-level events (best-effort in CI).
      # - fs_usage: Captures file system and network events from user-space daemons.
      - name: Run System Tracers
        run: |
          echo "Starting system-wide tracers for 30 seconds..."
          LOG_DIR="trace_logs"
          mkdir -p $LOG_DIR

          # Run dtrace listener (may have limited output in CI due to SIP)
          echo "--- DTrace Log ---" > $LOG_DIR/dtrace.log
          sudo ./dlistener.d >> $LOG_DIR/dtrace.log 2>&1 &
          DTRACE_PID=$!
          echo "dtrace listener started with PID $DTRACE_PID."

          # Run fs_usage on sharingd if it's running
          if [ -n "${{ env.SHARINGD_PID }}" ]; then
            echo "--- fs_usage Log for sharingd (PID ${{ env.SHARINGD_PID }}) ---" > $LOG_DIR/fs_usage_sharingd.log
            sudo fs_usage -w -f network pid ${{ env.SHARINGD_PID }} >> $LOG_DIR/fs_usage_sharingd.log 2>&1 &
            FS_USAGE_PID=$!
            echo "fs_usage started for sharingd with PID $FS_USAGE_PID."
          fi

          # Let tracers run for a while to capture activity
          sleep 30

          echo "Stopping tracers..."
          sudo kill $DTRACE_PID || true
          if [ -n "$FS_USAGE_PID" ]; then
            sudo kill $FS_USAGE_PID || true
          fi
          sleep 5 # Allow time for logs to flush
          echo "Tracers stopped."


      # Step 4: Capture a snapshot of open files and network connections
      # This helps identify which processes are communicating over the network.
      - name: Snapshot Open Network Sockets
        run: |
          echo "--- lsof Network Log ---" > trace_logs/lsof_output.log
          sudo lsof -i -n -P >> trace_logs/lsof_output.log 2>&1


      # Step 5: Upload all captured logs as an artifact
      # This package contains all the raw data for offline analysis.
      - name: Upload Trace Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: awdl-internal-trace-logs
          path: |
            ifconfig_output.txt
            trace_logs/
          retention-days: 7
          if-no-files-found: error
