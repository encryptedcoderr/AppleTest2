# This workflow performs internal reconnaissance of the AWDL/AirDrop stack on macOS.
# It uses a robust method to ensure the awdl0 interface is active, then traces
# related daemons and captures raw network packets to create a comprehensive
# dataset for vulnerability analysis.

name: Active Internal AWDL and AirDrop System Trace
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering for targeted runs

jobs:
  discover-activate-and-trace-awdl:
    runs-on: macos-latest

    steps:
      # Step 1: Discover network interfaces and key processes.
      - name: Discover Interfaces and Related Daemons
        id: discovery
        run: |
          echo "--- Discovering Network Interfaces ---"
          ifconfig -a > ifconfig_output.txt
          echo "\n--- Finding Key Daemons (sharingd, nearbyd, rapportd, airportd, wifip2pd) ---"
          PIDS=$(pgrep -x sharingd nearbyd rapportd airportd wifip2pd || echo "")
          if [ -n "$PIDS" ]; then
            echo "✅ Found daemon PIDs: $PIDS"
            echo "DAEMON_PIDS=$(echo $PIDS | tr '\n' ' ')" >> $GITHUB_ENV
          else
            echo "❌ No key daemons were running."
          fi

      # Step 2: Create and compile a utility to programmatically trigger AWDL.
      # This tool uses the CoreWLAN framework to force the creation of the awdl0 interface.
      - name: Build AWDL Activator Utility
        run: |
          echo "Creating AWDL Activator source..."
          cat > activator.m << 'EOF'
          #import <Foundation/Foundation.h>
          #import <CoreWLAN/CoreWLAN.h>

          int main(int argc, const char * argv[]) {
              @autoreleasepool {
                  NSLog(@"[Activator] Starting CoreWLAN scan to stimulate wireless stack...");
                  CWInterface *wifiInterface = [CWInterface interface];
                  if (!wifiInterface) {
                      NSLog(@"[Activator] Error: Could not get a Wi-Fi interface.");
                      return 1;
                  }
                  NSError *err = nil;
                  // A network scan is a reliable way to wake up the wireless stack and
                  // trigger the creation of associated interfaces like awdl0.
                  [wifiInterface scanForNetworksWithName:nil error:&err];
                  if (err) {
                      NSLog(@"[Activator] Scan failed with error: %@", err);
                      return 1;
                  }
                  NSLog(@"[Activator] Scan command issued successfully.");
              }
              return 0;
          }
          EOF
          echo "Compiling activator utility..."
          clang -fobjc-arc -framework Foundation -framework CoreWLAN activator.m -o activator
          echo "✅ Activator utility compiled."

      # Step 3: Proactively activate the awdl0 interface and wait until it is ready.
      # This new, robust step runs the activator and then waits for the interface to appear.
      - name: Activate and Verify awdl0 Interface
        run: |
          echo "Attempting to activate and verify the awdl0 interface..."
          # Loop for up to 30 seconds, running our activator and checking for the interface.
          for i in {1..6}; do
            # Run the activator to poke the wireless daemon.
            ./activator
            # Check if the interface now exists and is active.
            if ifconfig awdl0 2>/dev/null | grep -q "status: active"; then
              echo "✅ awdl0 interface is now active."
              exit 0
            fi
            echo "Waiting for awdl0 to be created and become active... (Attempt $i/6)"
            sleep 5
          done
          echo "❌ Error: Timed out waiting for awdl0 interface."
          ifconfig -a
          exit 1

      # Step 4: Run Tracers and Packet Capture on the now-active interface.
      # This step is streamlined now that activation is handled separately.
      - name: Run Tracers and Packet Capture
        run: |
          echo "Starting system-wide tracers and packet capture for 30 seconds..."
          LOG_DIR="trace_logs"
          mkdir -p $LOG_DIR

          # Create and start the DTrace listener
          echo '#!/usr/sbin/dtrace -s\n\nfbt:kernel:awdl*:entry { printf("KERNEL AWDL: PID %d (%s) triggered %s::%s\\n", pid, execname, probemod, probefunc); }' > dlistener.d
          chmod +x dlistener.d
          echo "--- DTrace Log ---" > $LOG_DIR/dtrace.log
          sudo ./dlistener.d >> $LOG_DIR/dtrace.log 2>&1 &
          DTRACE_PID=$!
          echo "dtrace listener started with PID $DTRACE_PID."

          # Run tcpdump to capture raw AWDL packets.
          echo "--- Packet Capture Log ---" > $LOG_DIR/awdl_capture.pcap
          sudo tcpdump -i awdl0 -w $LOG_DIR/awdl_capture.pcap >> $LOG_DIR/tcpdump.log 2>&1 &
          TCPDUMP_PID=$!
          echo "tcpdump started on awdl0 with PID $TCPDUMP_PID."

          # Run fs_usage on all discovered daemons with a delay to prevent resource conflicts.
          if [ -n "${{ env.DAEMON_PIDS }}" ]; then
            for pid in ${{ env.DAEMON_PIDS }}; do
              sleep 1 # Stagger the launch to avoid "Resource busy" errors.
              echo "--- fs_usage Log for PID $pid ---" > $LOG_DIR/fs_usage_$pid.log
              sudo fs_usage -w -f network pid $pid >> $LOG_DIR/fs_usage_$pid.log 2>&1 &
              echo "fs_usage started for PID $pid."
            done
          fi

          echo "Capturing activity for 30 seconds..."
          sleep 30

          echo "Stopping tracers..."
          sudo kill $DTRACE_PID $TCPDUMP_PID || true
          if [ -n "${{ env.DAEMON_PIDS }}" ]; then
            for pid in ${{ env.DAEMON_PIDS }}; do
              sudo pkill -f "fs_usage.*pid $pid" || true
            done
          fi
          sleep 5 # Allow time for logs to flush
          echo "Tracers stopped."


      # Step 5: Capture a snapshot of open files and network connections.
      - name: Snapshot Open Network Sockets
        run: |
          echo "--- lsof Network Log ---" > trace_logs/lsof_output.log
          sudo lsof -i -n -P >> trace_logs/lsof_output.log 2>&1


      # Step 6: Upload all captured logs as an artifact.
      - name: Upload Trace Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: awdl-internal-trace-logs
          path: |
            ifconfig_output.txt
            trace_logs/
          retention-days: 7
          if-no-files-found: error
