# This workflow builds and runs a complete fuzzing and tracing toolkit for AWDL/AirDrop.
# It compiles a BLE fuzzer, creates a session runner script, and executes them
# to actively probe for vulnerabilities while capturing detailed system logs,
# kernel events, and raw network traffic.

name: Build and Run AWDL Fuzzing Session
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering

jobs:
  build-and-fuzz:
    runs-on: macos-latest

    steps:
      # Step 1: Build the BLE Fuzzer utility.
      - name: Build BLE Fuzzer
        run: |
          echo "Creating ble-fuzzer.m source..."
          cat > ble-fuzzer.m << 'EOF'
          #import <Foundation/Foundation.h>
          #import <CoreBluetooth/CoreBluetooth.h>

          typedef NS_ENUM(NSInteger, FuzzStrategy) {
              FuzzStrategyCorruptLength, FuzzStrategyCorruptType,
              FuzzStrategyCorruptPayload, FuzzStrategyRandomBytes
          };

          @interface BLEFuzzer : NSObject <CBPeripheralManagerDelegate>
          @property (strong, nonatomic) CBPeripheralManager *peripheralManager;
          @property (strong, nonatomic) NSTimer *fuzzingTimer;
          @property (assign, nonatomic) FuzzStrategy currentStrategy;
          @end

          @implementation BLEFuzzer
          - (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral {
              if (peripheral.state == CBManagerStatePoweredOn) {
                  NSLog(@"[Fuzzer] Bluetooth is powered on. Starting fuzzing loop...");
                  self.fuzzingTimer = [NSTimer scheduledTimerWithTimeInterval:0.5
                                                                       target:self
                                                                     selector:@selector(fuzzTick:)
                                                                     userInfo:nil
                                                                      repeats:YES];
              } else {
                  NSLog(@"[Fuzzer] Bluetooth is not powered on. State: %ld", (long)peripheral.state);
                  [self.fuzzingTimer invalidate];
              }
          }

          - (void)fuzzTick:(NSTimer *)timer {
              [self.peripheralManager stopAdvertising];
              self.currentStrategy = (self.currentStrategy + 1) % 4;
              NSData *fuzzedPayload = [self generateFuzzedPayload];
              [self.peripheralManager startAdvertising:@{ CBAdvertisementDataManufacturerDataKey: fuzzedPayload }];
          }

          - (NSData *)generateFuzzedPayload {
              uint8_t base_data[] = {
                  0x02, 0x01, 0x06, 0x17, 0xff, 0x4c, 0x00, 0x05, 0x12,
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                  0xaa, 0xaa, 0xbb, 0xbb, 0xcc, 0xcc, 0xdd, 0xdd, 0x00
              };
              NSMutableData *data = [NSMutableData dataWithBytes:base_data length:sizeof(base_data)];
              uint8_t *bytes = [data mutableBytes];

              switch (self.currentStrategy) {
                  case FuzzStrategyCorruptLength:
                      NSLog(@"[Fuzzer] Strategy: Corrupt Length");
                      bytes[3] = arc4random_uniform(30);
                      bytes[9] = arc4random_uniform(20);
                      break;
                  case FuzzStrategyCorruptType:
                      NSLog(@"[Fuzzer] Strategy: Corrupt Type");
                      bytes[8] = arc4random_uniform(255);
                      break;
                  case FuzzStrategyCorruptPayload:
                      NSLog(@"[Fuzzer] Strategy: Corrupt Payload");
                      for (int i = 10; i < 27; i++) { bytes[i] = arc4random_uniform(256); }
                      break;
                  case FuzzStrategyRandomBytes:
                      NSLog(@"[Fuzzer] Strategy: Random Bytes");
                      NSUInteger randomLength = arc4random_uniform(30) + 1;
                      uint8_t randomBytes[randomLength];
                      for (int i = 0; i < randomLength; i++) { randomBytes[i] = arc4random_uniform(256); }
                      return [NSData dataWithBytes:randomBytes length:randomLength];
              }
              return data;
          }
          @end

          int main(int argc, const char * argv[]) {
              @autoreleasepool {
                  BLEFuzzer *fuzzer = [[BLEFuzzer alloc] init];
                  fuzzer.peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:fuzzer queue:nil];
                  NSLog(@"[Fuzzer] Initialized. Press Ctrl+C to stop.");
                  [[NSRunLoop currentRunLoop] run];
              }
              return 0;
          }
          EOF
          clang -fobjc-arc -framework Foundation -framework CoreBluetooth ble-fuzzer.m -o ble-fuzzer
          echo "✅ BLE Fuzzer compiled."

      # Step 2: Create the main session script to orchestrate the fuzzing and tracing.
      - name: Create Fuzzing Session Script
        run: |
          echo "Creating run_fuzz_session.sh script..."
          cat > run_fuzz_session.sh << 'EOF'
          #!/bin/bash
          if [ "$EUID" -ne 0 ]; then echo "Please run with sudo."; exit 1; fi

          LOG_DIR="fuzz_trace_logs"
          mkdir -p $LOG_DIR && rm -f $LOG_DIR/*
          echo "--- Fuzzing Session Started: $(date) ---" | tee $LOG_DIR/session.log

          # Start the BLE fuzzer in the background
          echo "[*] Starting BLE fuzzer..."
          sudo ./ble-fuzzer > $LOG_DIR/fuzzer.log 2>&1 &
          FUZZER_PID=$!
          echo "    Fuzzer running with PID $FUZZER_PID."

          # Wait for awdl0 to appear
          echo "[*] Waiting for awdl0 interface to activate..."
          for i in {1..6}; do
              if ifconfig awdl0 2>/dev/null | grep -q "status: active"; then
                  echo "✅ awdl0 is ACTIVE!"
                  break
              fi
              if [ $i -eq 6 ]; then
                  echo "❌ Timed out waiting for awdl0."
                  sudo kill $FUZZER_PID
                  exit 1
              fi
              sleep 5
          done

          # Start tracers now that the interface is active
          echo "[*] Starting tracers for 60 seconds..."
          echo '#!/usr/sbin/dtrace -s\n\nfbt:kernel:awdl*:entry { printf("KERNEL AWDL: PID %d (%s) triggered %s::%s\\n", pid, execname, probemod, probefunc); }' > dlistener.d
          chmod +x dlistener.d
          sudo ./dlistener.d > $LOG_DIR/dtrace.log 2>&1 &
          DTRACE_PID=$!

          sudo tcpdump -i awdl0 -w $LOG_DIR/awdl_capture.pcap > $LOG_DIR/tcpdump.log 2>&1 &
          TCPDUMP_PID=$!

          # Trace all relevant daemons
          PIDS=$(pgrep -x sharingd nearbyd rapportd airportd wifip2pd || echo "")
          if [ -n "$PIDS" ]; then
              for pid in $PIDS; do
                  sudo fs_usage -w -f network pid $pid > "$LOG_DIR/fs_usage_$pid.log" 2>&1 &
              done
          fi

          sleep 60

          echo "[*] Stopping fuzzer and all tracers..."
          sudo kill $FUZZER_PID $DTRACE_PID $TCPDUMP_PID || true
          if [ -n "$PIDS" ]; then
              for pid in $PIDS; do sudo pkill -f "fs_usage.*pid $pid" || true; done
          fi
          
          echo "✅ Fuzzing session complete. Logs are in '$LOG_DIR'."
          ls -l $LOG_DIR
          EOF
          chmod +x run_fuzz_session.sh

      # Step 3: Execute the fuzzing session.
      - name: Run Fuzzing and Tracing Session
        run: sudo ./run_fuzz_session.sh

      # Step 4: Upload all captured logs as an artifact for analysis.
      - name: Upload Fuzzing Artifacts
        if: always() # Ensure logs are uploaded even if a step fails
        uses: actions/upload-artifact@v4
        with:
          name: awdl-fuzzing-logs
          path: fuzz_trace_logs/
          retention-days: 7
