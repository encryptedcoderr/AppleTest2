# This workflow performs internal reconnaissance of the AWDL/AirDrop stack on macOS.
# It identifies the awdl0 interface, finds all related daemons, actively
# stimulates AWDL activity, and then uses powerful system tracing tools to
# monitor and log the resulting system calls and network interactions.

name: Active Internal AWDL and AirDrop System Trace
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering for targeted runs

jobs:
  discover-activate-and-trace-awdl:
    runs-on: macos-latest

    steps:
      # Step 1: Discover network interfaces and key processes
      # We find all daemons related to sharing and proximity services.
      - name: Discover Interfaces and Related Daemons
        id: discovery
        run: |
          echo "--- Discovering Network Interfaces ---"
          ifconfig -a > ifconfig_output.txt
          if grep -q "awdl0" ifconfig_output.txt; then
            echo "✅ awdl0 interface found."
          else
            echo "⚠️ awdl0 interface not found. It may be inactive but we will attempt to bring it up."
          fi

          echo "\n--- Finding Key Daemons (sharingd, nearbyd, rapportd) ---"
          PIDS=$(pgrep -x sharingd nearbyd rapportd || echo "")
          if [ -n "$PIDS" ]; then
            echo "✅ Found daemon PIDs: $PIDS"
            # Save PIDs for later steps. Format as a space-separated string.
            echo "DAEMON_PIDS=$(echo $PIDS | tr '\n' ' ')" >> $GITHUB_ENV
          else
            echo "❌ No key daemons (sharingd, nearbyd, rapportd) were running."
          fi

      # Step 2: Create a more comprehensive DTrace listener
      # This script now uses wildcards to trace all AWDL-related kernel functions.
      - name: Create Enhanced AWDL DTrace Listener
        run: |
          echo "Creating enhanced DTrace script to monitor kernel-level AWDL activity..."
          cat > dlistener.d << 'EOF'
          #!/usr/sbin/dtrace -s

          # This script traces all AWDL kernel functions to capture a broad range of events.
          # NOTE: This requires System Integrity Protection (SIP) to be at least partially disabled
          # for full visibility.

          fbt:kernel:awdl*:entry
          {
            printf("KERNEL AWDL: PID %d (%s) triggered %s::%s\n", pid, execname, probemod, probefunc);
          }
          EOF
          chmod +x dlistener.d
          echo "✅ DTrace script created."

      # Step 3: Run Tracers and Activation Script
      # This is the core step. We run an activation script in the background
      # to stimulate AWDL while concurrently logging all activity.
      - name: Run Activation and System Tracers
        run: |
          echo "Starting system-wide tracers and activation script for 30 seconds..."
          LOG_DIR="trace_logs"
          mkdir -p $LOG_DIR

          # Create and run a background script to activate the awdl0 interface
          cat > activate.sh << 'EOF'
          #!/bin/bash
          echo "Activation script started. Will attempt to bring up awdl0 every 5 seconds."
          while true; do
            sudo ifconfig awdl0 up
            sleep 5
          done
          EOF
          chmod +x activate.sh
          ./activate.sh &
          ACTIVATION_PID=$!
          echo "Activation script started with PID $ACTIVATION_PID"

          # Run dtrace listener (may have limited output in CI due to SIP)
          echo "--- DTrace Log ---" > $LOG_DIR/dtrace.log
          sudo ./dlistener.d >> $LOG_DIR/dtrace.log 2>&1 &
          DTRACE_PID=$!
          echo "dtrace listener started with PID $DTRACE_PID."

          # Run fs_usage on all discovered daemons
          if [ -n "${{ env.DAEMON_PIDS }}" ]; then
            for pid in ${{ env.DAEMON_PIDS }}; do
              echo "--- fs_usage Log for PID $pid ---" > $LOG_DIR/fs_usage_$pid.log
              sudo fs_usage -w -f network pid $pid >> $LOG_DIR/fs_usage_$pid.log 2>&1 &
              echo "fs_usage started for PID $pid."
            done
          fi

          # Let tracers and activation run to capture activity
          echo "Capturing activity for 30 seconds..."
          sleep 30

          echo "Stopping tracers and activation script..."
          sudo kill $ACTIVATION_PID $DTRACE_PID || true
          if [ -n "${{ env.DAEMON_PIDS }}" ]; then
            for pid in ${{ env.DAEMON_PIDS }}; do
              sudo pkill -f "fs_usage.*pid $pid" || true
            done
          fi
          sleep 5 # Allow time for logs to flush
          echo "Tracers stopped."


      # Step 4: Capture a snapshot of open files and network connections
      # This gives context to the trace logs, showing which processes held which sockets.
      - name: Snapshot Open Network Sockets
        run: |
          echo "--- lsof Network Log ---" > trace_logs/lsof_output.log
          sudo lsof -i -n -P >> trace_logs/lsof_output.log 2>&1


      # Step 5: Upload all captured logs as an artifact
      # This package contains all the raw data for offline analysis.
      - name: Upload Trace Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: awdl-internal-trace-logs
          path: |
            ifconfig_output.txt
            trace_logs/
          retention-days: 7
          if-no-files-found: error
