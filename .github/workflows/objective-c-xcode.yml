# This workflow builds and executes a targeted IOCTL fuzzer against macOS
# wireless drivers. It programmatically activates AirDrop to create the necessary
# interface, then runs the fuzzer while capturing system call traces and
# raw network packets to analyze the driver's response.

name: Build and Run AWDL IOCTL Fuzzing Session
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering

jobs:
  build-and-run-ioctl-fuzzer:
    runs-on: macos-latest

    steps:
      # Step 1: Create and compile the ioctl_fuzzer utility from source.
      - name: Build IOCTL Fuzzer
        run: |
          echo "Creating ioctl_fuzzer.c source..."
          cat > ioctl_fuzzer.c << 'EOF'
          #include <stdio.h>
          #include <stdlib.h>
          #include <string.h>
          #include <unistd.h>
          #include <fcntl.h>
          #include <sys/ioctl.h>
          #include <time.h>
          #include <errno.h>

          // We are now focusing on the single IOCTL command that returned an unusual success code.
          #define TARGET_IOCTL_CMD 0x4004667A

          // We will test a range of buffer sizes to probe for parsing errors.
          #define MAX_FUZZ_BUFFER_SIZE 8192

          /**
           * Generates a buffer of random bytes.
           * @param buffer The buffer to fill with random data.
           * @param size The size of the buffer to generate.
           */
          void generate_fuzz_buffer(char *buffer, size_t size) {
              for (size_t i = 0; i < size; i++) {
                  buffer[i] = rand() % 256;
              }
          }

          /**
           * The main fuzzing function. It now focuses on a single command
           * and varies the size of the payload.
           * @param device_path The path to the device file for the driver (e.g., "/dev/bpf0").
           */
          void fuzz_ioctl(const char *device_path) {
              int fd;
              char fuzz_buffer[MAX_FUZZ_BUFFER_SIZE];
              
              printf("[Fuzzer] Opening device: %s\n", device_path);
              fd = open(device_path, O_RDWR);
              if (fd < 0) {
                  perror("[Fuzzer] Error opening device. This is expected if the device node is not present in the CI environment. The fuzzer will now exit");
                  return;
              }

              printf("[Fuzzer] Starting targeted IOCTL fuzzing loop. Press Ctrl+C to stop.\n");

              int iteration = 0;
              while (1) {
                  // Vary the size of the fuzzing buffer on each iteration.
                  size_t current_fuzz_size = (rand() % MAX_FUZZ_BUFFER_SIZE) + 1;
                  
                  generate_fuzz_buffer(fuzz_buffer, current_fuzz_size);

                  printf("[Fuzzer] Iteration %d: Fuzzing cmd 0x%lx with a %zu-byte buffer...\n", iteration, TARGET_IOCTL_CMD, current_fuzz_size);

                  // Send the fuzzed data to the driver.
                  if (ioctl(fd, TARGET_IOCTL_CMD, fuzz_buffer) < 0) {
                      fprintf(stderr, "    > ioctl failed with error %d (%s)\n", errno, strerror(errno));
                  } else {
                      printf("    > SUCCESS! ioctl command 0x%lx returned non-error. This is highly unusual!\n", TARGET_IOCTL_CMD);
                  }

                  iteration++;
                  usleep(100000); // 100ms
              }

              close(fd);
          }

          int main(int argc, char **argv) {
              if (argc != 2) {
                  fprintf(stderr, "Usage: %s <device_path>\n", argv[0]);
                  fprintf(stderr, "Example: sudo %s /dev/bpf0\n", argv[0]);
                  return 1;
              }
              srand(time(NULL));
              fuzz_ioctl(argv[1]);
              return 0;
          }
          EOF
          clang ioctl_fuzzer.c -o ioctl_fuzzer
          echo "✅ IOCTL Fuzzer compiled."

      # Step 2: Create the main session script to orchestrate the fuzzing and tracing.
      - name: Create Fuzzing Session Script
        run: |
          echo "Creating run_fuzz_session.sh script..."
          cat > run_fuzz_session.sh << 'EOF'
          #!/bin/bash
          if [ "$EUID" -ne 0 ]; then echo "Please run with sudo."; exit 1; fi

          LOG_DIR="fuzz_trace_logs"
          mkdir -p $LOG_DIR && rm -f $LOG_DIR/*
          echo "--- Fuzzing Session Started: $(date) ---" | tee $LOG_DIR/session.log

          # --- Activation and Dynamic Interface Discovery ---
          echo "[*] Activating AirDrop and discovering wireless interface..."
          ORIGINAL_MODE=$(defaults read com.apple.sharingd DiscoverableMode 2>/dev/null || echo "Contacts Only")
          sudo defaults write com.apple.sharingd DiscoverableMode Everyone
          sudo pkill sharingd || true
          sleep 5

          TARGET_INTERFACE=""
          for i in {1..6}; do
              TARGET_INTERFACE=$(ifconfig -l | tr ' ' '\n' | grep -E '^(awdl|llw)[0-9]+' || echo "")
              if [ -n "$TARGET_INTERFACE" ]; then
                  echo "✅ Discovered P2P interface: $TARGET_INTERFACE"
                  break
              fi
              echo "    Waiting for P2P interface to appear... (Attempt $i/6)"
              sleep 5
          done

          if [ -z "$TARGET_INTERFACE" ]; then
              echo "⚠️ Could not discover a P2P interface. Tracers may not capture relevant data."
          fi
          
          # --- Fuzzing and Tracing Logic ---
          echo "[*] Starting tracers and IOCTL fuzzer..."

          # Trace relevant daemons using dtruss.
          PIDS_TO_TRACE=$(pgrep -x sharingd nearbyd rapportd airportd wifip2pd || echo "")
          if [ -n "$PIDS_TO_TRACE" ]; then
              for pid in $PIDS_TO_TRACE; do
                  PROC_NAME=$(ps -p $pid -o comm= | xargs basename)
                  echo "    Starting dtruss for $PROC_NAME (PID $pid)..."
                  sudo dtruss -p $pid -f -d > "$LOG_DIR/dtruss_$PROC_NAME_$pid.log" 2>&1 &
              done
          fi
          
          # Start packet capture if the interface was found.
          if [ -n "$TARGET_INTERFACE" ]; then
              sudo tcpdump -i $TARGET_INTERFACE -w $LOG_DIR/capture.pcap > $LOG_DIR/tcpdump.log 2>&1 &
              TCPDUMP_PID=$!
          fi
          
          # Start the IOCTL fuzzer.
          echo "[*] Launching IOCTL fuzzer against /dev/bpf0 for 60 seconds..."
          sudo ./ioctl_fuzzer /dev/bpf0 > "$LOG_DIR/fuzzer.log" 2>&1 &
          FUZZER_PID=$!

          sleep 60

          echo "[*] Stopping fuzzer and all tracers..."
          sudo kill $FUZZER_PID $TCPDUMP_PID || true
          sudo pkill dtruss || true
          
          # --- Cleanup ---
          echo "[*] Restoring original AirDrop settings..."
          sudo defaults write com.apple.sharingd DiscoverableMode "$ORIGINAL_MODE"
          sudo pkill sharingd
          echo "    Restored AirDrop mode to '$ORIGINAL_MODE'."

          echo "✅ Fuzzing session complete. Logs are in '$LOG_DIR'."
          ls -l $LOG_DIR
          EOF
          chmod +x run_fuzz_session.sh

      # Step 3: Execute the fuzzing session.
      - name: Run Fuzzing and Tracing Session
        run: sudo ./run_fuzz_session.sh

      # Step 4: Upload all captured logs as an artifact for analysis.
      - name: Upload Fuzzing Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: awdl-ioctl-fuzz-logs
          path: fuzz_trace_logs/
          retention-days: 7
