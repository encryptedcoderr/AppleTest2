//Tracking
//sudo tcpdump -i wlan0 -n -vv -s 0 -c 100 -W 100 -e "wlan type mgt and wlan subtype action and ether host 00:25:00:ff:94:73"
tcpdump: can't parse filter expression: syntax error

//sudo tcpdump -i wlan0 -n -vv -s 0 -c 100 -W 100 -e 'wlan type mgt subtype action' | grep -A 5 "Type: BSS Steering"
tcpdump: can't parse filter expression: syntax error

//TrackingTshark
//sudo tshark -i wlan0 -Y "wlan.fc.type == 0 and wlan.fc.subtype == 13 and wlan.vendor == 0x0017f2" -e awdl.bsssteering.msg_len -T fields
Running as user "root" and group "root". This could be dangerous.
tshark: Some fields aren't valid:
        awdl.bsssteering.msg_len
                                  
#include <stdio.h>
#include <string.h>
#include <pcap.h>
#include "awdl_structs.h" // Assuming this has the structure definitions

void packet_handler(unsigned char *args, const struct pcap_pkthdr *header, const unsigned char *packet) {
    // Assume packet includes radiotap header, IEEE 802.11 header, AWDL action frame, etc.
    const struct ieee80211_hdr *wifi_hdr = (struct ieee80211_hdr*)(packet + sizeof(struct radiotap_hdr));
    const struct awdl_action *action = (struct awdl_action*)(wifi_hdr + 1);
    
    if (action->category == IEEE80211_VENDOR_SPECIFIC && 
        memcmp(&action->oui, &awdl_oui, sizeof(awdl_oui)) == 0 &&
        action->type == AWDL_TYPE) {
        
        uint8_t *tlv_ptr = (uint8_t*)(action + 1);
        uint8_t *tlv_end = (uint8_t*)packet + header->caplen;
        
        while(tlv_ptr < tlv_end - 2) { // Ensure we can at least read type and length
            struct bss_steering_tlv *bs = (struct bss_steering_tlv*)tlv_ptr;
            if (bs->type == 0x1d) {
                printf("BSS Steering MsgLen: %u\n", bs->steeringMsgLen);
                break; // Found what we're looking for
            }
            tlv_ptr += 3 + bs->length; // Move to next TLV
        }
    }
}

int main() {
    char *dev = "wlan1"; // or whatever your interface is
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);
    if (handle == NULL) {
        fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
        return(2);
    }
    pcap_loop(handle, 0, packet_handler, NULL);
    pcap_close(handle);
    return 0;
}