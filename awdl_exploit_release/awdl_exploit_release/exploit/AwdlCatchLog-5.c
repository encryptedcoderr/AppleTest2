//Tracking
GRok can get us function formulas

Determine if packet is awdl in python
from scapy.all import *

# Define a function to check if a packet is an AWDL action frame
def is_awdl_action(pkt):
    return (pkt.haslayer(Dot11) and 
            pkt[Dot11].type == 0 and  # Management frame
            pkt[Dot11].subtype == 13 and  # Action frame
            pkt.haslayer(Dot11Action) and 
            pkt[Dot11Action].category == 127 and  # Vendor Specific
            pkt.getlayer(Raw) and 
            pkt.getlayer(Raw).load[:3] == b'\x00\x17\xf2')  # Apple OUI

# Sniff for AWDL packets
sniff(iface="mon0", filter="type mgt subtype action", prn=lambda x: print(x.summary()) if is_awdl_action(x) else None, store=0)

//sudo tcpdump -i wlan3 -n -vv -s 0 -c 100 -W 100 port 5151
//sudo tcpdump -i mon0 -n -vv -s 0 -c 100 -W 100 -e 'wlan type mgt subtype action'
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <pcap/pcap.h>
#include <net/ethernet.h>
#include "awdl_structs.h"

// Define the BSSID for Apple
const struct ether_addr apple_bssid = {0x00, 0x25, 0x00, 0xff, 0x94, 0x73};
const int AWDL_CHANNEL = 6;

// Function to set up packet injection
void setup_pcap(char *interface, pcap_t **handle) {
    char errbuf[PCAP_ERRBUF_SIZE];
    *handle = pcap_open_live(interface, BUFSIZ, 1, 1000, errbuf);
    if (*handle == NULL) {
        fprintf(stderr, "Couldn't open device %s: %s\n", interface, errbuf);
        exit(2);
    }
}

// Function to send AWDL sync packet
void send_awdl_sync(pcap_t *handle, struct ether_addr target_mac) {
    struct awdl_sync_params_tlv sp = {0};
    sp.type = 4; // Sync Parameters TLV type
    sp.length = sizeof(sp) - 3; // Length of TLV minus the type and length fields
    
    // Set channel based on Wireshark data
    sp.next_aw_channel = 6;  // Matches 'Next AW Channel: 6'
    sp.master_channel = 6;   // Matches 'Master Channel: 6'

    // Update sync parameters based on Wireshark data
    sp.tx_down_counter = 39; // Matches 'Tx Counter: 39 TU'
    sp.guard_time = 0;       // Matches 'Guard Time: 0'
    sp.aw_period = 16;       // Matches 'Availability Window Period: 16 TU'
    sp.af_period = 110;      // Matches 'Action Frame Period: 110 TU'
    sp.flags = 0x1800;       // Matches 'AWDL Flags: 0x1800'
    sp.aw_ext_length = 16;   // Matches 'Availability Window Extension Length: 16 TU'
    sp.aw_com_length = 16;   // Matches 'Availability Window Common Length: 16 TU'
    sp.remaining_aw_length = 0; // Matches 'Remaining Availability Window Length: 0 TU'
    sp.min_ext = 3;          // Matches 'Minimum Extension Count: 3'
    sp.max_ext_multicast = 3; // Matches 'Maximum Extension Count for Multicast: 3'
    sp.max_ext_unicast = 3;  // Matches 'Maximum Extension Count for Unicast: 3'
    sp.max_ext_af = 3;       // Matches 'Maximum Extension Count for Action Frame: 3'
    memcpy(&sp.master_addr, &target_mac, 6); // Use target MAC as master, adjust if necessary
    sp.presence_mode = 4;    // Matches 'Presence Mode: 4'
    sp.next_aw_seq = 22817;  // Matches 'AW Sequence Number: 22817'
    sp.ap_alignment = 0;     // Matches 'AP Beacon alignment delta: 0'

    // Channel sequence setup based on Wireshark data
    sp.count = 15;           // Matches 'Number of Channels (+1): 15'
    sp.encoding = 1;         // Matches 'Encoding: Legacy (1)'
    sp.duplicate_count = 0;  // Matches 'Duplicate: 0'
    sp.step_count = 3;       // Matches 'Step Count (+1): 3'
    sp.fill_channel = 0xffff;// Matches 'Fill Channel: Repeat Current (0xffff)'

    // Note: Channel sequence in Wireshark data is complex with different channels and flags. 
    // Here, we simplify by using channel 6 repeatedly as an example. In practice, this should be adjusted.
    for (int i = 0; i < 16; i++) {
        sp.seq[i] = 0x0006; // Channel 6 in hex format
    }

    pkt_buf_t *sync = pkt_buf_wrap(&sp, sizeof(sp));
    
    inject(handle, 
        RT(),
        WIFI(apple_bssid, target_mac), // Use Apple's BSSID as destination, target MAC as source
        AWDL(),
        sync,
        PKT_END());
}

int main() {
    char *interface = "wlan3";
    pcap_t *handle;
    setup_pcap(interface, &handle);

    // The MAC address starts with 'de' but is dynamic
    struct ether_addr target_mac = {0xde, 0x2d, 0x17, 0xc3, 0x52, 0x32}; // Example, will change

    for (int i = 0; i < 10; i++) { // Send sync packets several times
        send_awdl_sync(handle, target_mac);
        usleep(500000); // Sleep for half a second between sends
    }

    pcap_close(handle);
    return 0;
}