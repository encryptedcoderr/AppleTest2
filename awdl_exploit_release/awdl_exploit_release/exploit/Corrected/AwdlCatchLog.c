#include <pcap/pcap.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <netinet/ether.h>
#include <stdlib.h>  // For system()
#include <sys/wait.h>  // For WIFEXITED and WEXITSTATUS
#include "awdl_structs.h"
#include "wifi_control.h"

#define TARGET_MAC "de:2d:17:c3:52:32" // (Past Iphone mac)
const struct ether_addr awdl_bssid = {{0x00, 0x25, 0x00, 0xff, 0x94, 0x73}}; // (BSSID of Apple awdl interface all device macs interact with)
int set_wifi_channel(const char *interface, uint8_t channel) {
    char command[256];
    snprintf(command, sizeof(command), "iw dev %s set channel %d", interface, channel);
    
    int result = system(command);
    if (result == -1 || !WIFEXITED(result) || WEXITSTATUS(result) != 0) {
        perror("Error setting channel");
        return -1;
    }
    return 0;
}

int set_channel_and_filter(pcap_t *handle, const char *interface) {
    if (set_wifi_channel(interface, 6) != 0) {
        fprintf(stderr, "Failed to set channel to 6 for interface %s\n", interface);
        return -1;
    }

    char filter_exp[100];
    snprintf(filter_exp, sizeof(filter_exp), "wlan addr1 %s or wlan addr2 %s or wlan addr3 %s", TARGET_MAC, TARGET_MAC, TARGET_MAC);
    struct bpf_program fp;

    if (pcap_compile(handle, &fp, filter_exp, 1, PCAP_NETMASK_UNKNOWN) == -1) {
        fprintf(stderr, "Couldn't parse filter %s: %s\n", filter_exp, pcap_geterr(handle));
        return -1;
    }

    if (pcap_setfilter(handle, &fp) == -1) {
        fprintf(stderr, "Couldn't install filter %s: %s\n", filter_exp, pcap_geterr(handle));
        pcap_freecode(&fp);
        return -1;
    }
    pcap_freecode(&fp);
    return 0;
}

int is_awdl_frame(const unsigned char *bytes) {
    struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(bytes + sizeof(struct ieee80211_radiotap_header_compat));
    struct awdl_action *action = (struct awdl_action *)(hdr + 1);

    if ((hdr->frame_control & (IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) == 
        (IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION) &&
        action->category == IEEE80211_VENDOR_SPECIFIC &&
        memcmp(&action->oui, &awdl_bssid, sizeof(awdl_bssid)) == 0 &&
        action->type == AWDL_TYPE &&
        action->version == AWDL_VERSION_COMPAT) {
        return 1;
    }
    return 0;
}

void log_awdl_info(unsigned char* user, const struct pcap_pkthdr *h, const unsigned char *bytes) {
    if (!is_awdl_frame(bytes)) return;

    FILE *logfile = fopen("awdl_info.log", "a");
    if (logfile == NULL) {
        perror("Unable to open log file");
        return;
    }

    time_t now = time(NULL);
    char* dt = ctime(&now);
    fprintf(logfile, "AWDL Frame Received - %s", dt);

    struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(bytes + sizeof(struct ieee80211_radiotap_header_compat));
    struct awdl_action *action = (struct awdl_action *)(hdr + 1);

    fprintf(logfile, "Source MAC: %s\n", ether_ntoa((const struct ether_addr *)&hdr->src_addr));
    fprintf(logfile, "Destination MAC: %s\n", ether_ntoa((const struct ether_addr *)&hdr->dst_addr));
    fprintf(logfile, "AWDL Subtype: 0x%02x\n", action->subtype);
    fprintf(logfile, "PHY TX Timestamp: %u\n", action->phy_tx);
    fprintf(logfile, "Target TX Timestamp: %u\n", action->target_tx);

    fprintf(logfile, "-----------------------------------\n");
    fclose(logfile);
}

int main() {
    char *interface = "wlan1mon";
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *handle = pcap_open_live(interface, BUFSIZ, 1, 1000, errbuf);
    if (handle == NULL) {
        fprintf(stderr, "Couldn't open device %s: %s\n", interface, errbuf);
        return 2;
    }

    if (set_channel_and_filter(handle, interface) != 0) {
        pcap_close(handle);
        return 2;
    }

    pcap_loop(handle, 0, log_awdl_info, NULL);
    pcap_close(handle);
    return 0;
}

