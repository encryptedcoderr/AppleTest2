#include <stdio.h>
#include <string.h>
#include <pcap.h>
#include "awdl_structs.h" // Assuming this file has the structure definitions

// Define the OUI for Apple
const struct oui awdl_oui = {0x00, 0x17, 0xF2};

void print_mac_addr(struct ether_addr *mac) {
    printf("%02x:%02x:%02x:%02x:%02x:%02x", 
           mac->ether_addr_octet[0], mac->ether_addr_octet[1], 
           mac->ether_addr_octet[2], mac->ether_addr_octet[3], 
           mac->ether_addr_octet[4], mac->ether_addr_octet[5]);
}

void packet_handler(unsigned char *args, const struct pcap_pkthdr *header, const unsigned char *packet) {
    // Skip radiotap header size, which can vary. Here, we assume a fixed size, adjust if necessary.
    const struct ieee80211_hdr *wifi_hdr = (struct ieee80211_hdr*)(packet + 24); // Adjust this offset based on your radiotap header size
    const struct awdl_action *action = (struct awdl_action*)(wifi_hdr + 1);
    
    if (action->category == IEEE80211_VENDOR_SPECIFIC && 
        memcmp(&action->oui, &awdl_oui, sizeof(awdl_oui)) == 0 &&
        action->type == AWDL_TYPE) {
        
        uint8_t *tlv_ptr = (uint8_t*)(action + 1);
        uint8_t *tlv_end = (uint8_t*)packet + header->caplen;
        
        while(tlv_ptr < tlv_end - 2) { // Ensure we can at least read type and length
            struct bss_steering_tlv *bs = (struct bss_steering_tlv*)tlv_ptr;
            if (bs->type == 0x1d) {
                printf("BSS Steering Info:\n");
                printf("  MsgLen: %u\n", bs->steeringMsgLen);
                printf("  Peer Count: %u\n", bs->peer_count);

                printf("  Peer MACs:\n");
                for (int i = 0; i < 8; i++) {
                    printf("    Peer %d: ", i);
                    print_mac_addr(&bs->peer_macs[i]);
                    printf("\n");
                }

                printf("  BSSID: ");
                print_mac_addr(&bs->BSSID);
                printf("\n");

                printf("  Steering Timeout Threshold: %u\n", bs->steeringTimeoutThreshold);
                printf("  SSID Length: %u\n", bs->SSID_len);
                
                // Print SSID, ensuring we don't go out of bounds
                printf("  SSID: ");
                for (int i = 0; i < bs->SSID_len && i < sizeof(bs->SSID); i++) {
                    printf("%c", bs->SSID[i]);
                }
                printf("\n");

                printf("  Infrastructure Channel: %u\n", bs->infra_channel);
                printf("  Steering Command Flags: 0x%04x\n", bs->steeringCmdFlags);

                break; // Found what we're looking for
            }
            tlv_ptr += 3 + bs->length; // Move to next TLV, 3 bytes for type and length
        }
    }
}

int main() {
    char *dev = "wlan0"; // or whatever your interface name is
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);
    if (handle == NULL) {
        fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
        return 2;
    }
    
    // Set up the filter for AWDL action frames
    struct bpf_program fp;
    char filter_exp[] = "wlan type mgt subtype action";
    if (pcap_compile(handle, &fp, filter_exp, 1, PCAP_NETMASK_UNKNOWN) == -1) {
        fprintf(stderr, "Couldn't parse filter %s: %s\n", filter_exp, pcap_geterr(handle));
        return 2;
    }
    if (pcap_setfilter(handle, &fp) == -1) {
        fprintf(stderr, "Couldn't install filter %s: %s\n", filter_exp, pcap_geterr(handle));
        return 2;
    }

    // Loop through packets
    pcap_loop(handle, 0, packet_handler, NULL);
    
    pcap_close(handle);
    return 0;
}