#!/usr/bin/python
import subprocess
import sys
import struct

if len(sys.argv) < 2:
    print('no input')
    exit()

infile = sys.argv[1]

# compile it
cmd = 'xcrun --sdk iphoneos clang -arch arm64 -fno-stack-protector -fPIC -O2 -Xlinker -sectalign -Xlinker __TEXT -Xlinker __text -Xlinker 0x4000 -Xlinker -sectalign -Xlinker __TEXT -Xlinker __cstring -Xlinker 0x4 -Os -fomit-frame-pointer -o stage2 %s' % infile 
print(cmd)
output = subprocess.check_output(cmd, shell=True)
print(output);

# there should only be 2 relevant sections: __TEXT __text and __TEXT __cstring, and they should be next to each other

# get the bytes
cmd = 'xcrun --sdk iphoneos otool -s __TEXT __text stage2 | grep "^00" | cut -f 2 && xcrun --sdk iphoneos otool -s __TEXT __cstring stage2 | grep "^00" | cut -f 2'
print(cmd)

outstr = 'uint32_t shellcode[] = {\n'
outbin = ''
output = subprocess.check_output(cmd, shell=True)
lines = output.split('\n')
total_words = 0
for l in lines[:-1]:
    words = l.split(' ')
    for idx, word in enumerate(words[:-1]):
        # sometimes the length of the section won't be on a 4 byte boundary so we'll get individual bytes
        if len(word) == 2:
            # collect the rest of the bytes and form the byte:
            rem = (len(words)-1) - idx
            s = ''
            if (rem == 3):
                s = '00%s%s%s' % (words[idx+2], words[idx+1], words[idx])
            if (rem == 2):
                s = '0000%s%s' % (words[idx+1], words[idx])
            if (rem == 1):
                s = '000000%s' % (words[idx])

            u32 = int(s, 16)
            outbin += struct.pack('<I', u32)

            outstr += '  0x%s,\n' %s
            total_words += 1
            break
        u32 = int(word, 16)
        outbin += struct.pack('<I', u32)
        outstr += '  0x%s,\n' % word
        total_words += 1

outstr = outstr[:-2]
outstr += '};\n'

print(outstr)

fout = open('stage2.bin', 'w')
fout.write(outbin)







