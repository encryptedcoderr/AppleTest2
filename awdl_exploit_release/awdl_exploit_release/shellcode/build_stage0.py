#!/usr/bin/python
import subprocess
import sys

if len(sys.argv) < 2:
    print('no input')
    exit()

infile = sys.argv[1]

# assemble it:
cmd = 'xcrun --sdk iphoneos clang -arch arm64 -fPIC -o stage0 -c %s' % infile
print(cmd)
output = subprocess.check_output(cmd, shell=True)
print(output);

# get the bytes
cmd = 'xcrun --sdk iphoneos otool -s __TEXT __text stage0 | grep "^00" | cut -f 2'
print(cmd)

outstr = 'uint32_t shellcode[] = {\n'

output = subprocess.check_output(cmd, shell=True)
lines = output.split('\n')
total_words = 0
for l in lines[:-1]:
    words = l.split(' ')
    for word in words[:-1]:
        outstr += '  0x%s,\n' % word
        total_words += 1

outstr = outstr[:-2]
outstr += '};\n'

print(outstr)

# generate code to resolve the symbols
cmd = 'nm -a shellcode.o'

outstr = '''
#define SYM(type, offset, val) *(type*)(((uint8_t*)shellcode)+offset) = val

void rebase_shellcode(uint64_t slide) {
'''

output = subprocess.check_output(cmd, shell=True)
lines = output.split('\n')
syms = []
for l in lines[1:-1]:
    fields = l.split(' ')
    offset = int(fields[0], 16)
    sym = fields[2]
    syms.append( (offset, sym) )

syms.sort()

full_syms = []

for i in range(len(syms)):
    byte_size = 0
    if i < len(syms)-1:
        # can work out the size by the offset to the next sym:
        this_offset = syms[i][0]
        next_offset = syms[i+1][0]
        byte_size = next_offset-this_offset
    else:
        # can work out the size by the remaining size:
        byte_size = (total_words*4)-syms[i][0]

    type_str = 'uint%d_t' % (byte_size*8)
    full_syms.append( (syms[i][0], syms[i][1], type_str) )

for (offset, sym_name, type_str) in full_syms:
    outstr += '  %s %s = 0x1234;\n' % (type_str, sym_name)

outstr += '\n'

for (offset, sym_name, type_str) in full_syms:
    outstr += '  SYM(%s, 0x%x, %s);\n' % (type_str, offset, sym_name)

outstr += '}\n'

print(outstr)









